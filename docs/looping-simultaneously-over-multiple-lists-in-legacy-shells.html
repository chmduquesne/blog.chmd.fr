<!DOCTYPE html>
<html lang="en">
<head>
    <title>Looping simultaneously over multiple lists in legacy shells</title>
    <meta charset="utf-8" />
    <link href="http://blog.chmd.fr/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Ch-M.D Full Atom Feed" />
    <link href="http://blog.chmd.fr/feeds/howto.atom.xml" type="application/atom+xml" rel="alternate" title="Ch-M.D Categories Atom Feed" />
    <link rel="stylesheet" href="theme/css/rdark.css" />
    <link rel="stylesheet" type="text/css" href="theme/css/main.css" />
</head>

<body id="index" class="home">
    <header id="banner" class="body">
        <h1><a href="http://blog.chmd.fr">Ch-M.D <strong></strong></a></h1>
    </header><!-- /#banner -->
<section id="content" class="body">
<header>
    <h1 class="entry-title">
        <a href="looping-simultaneously-over-multiple-lists-in-legacy-shells.html" rel="bookmark" title="Permalink to Looping simultaneously over multiple lists in legacy shells">
                Looping simultaneously over multiple lists in legacy shells
        </a>
    </h1>
</header>
<article>
    <div class="entry-content">
    <p>I was recently confronted to the problem of looping over multiple lists
simultaneously in a legacy shell, and coming up with an elegant solution
was an interesting challenge. Legacy shells do not support arrays, which
means there is no structure you can directly address with an index i in
order to get the iᵗʰ element. How can one then process multiple lists
simultaneously in order to get the first element of each list, then the
second element of each list, then the third... and so on?</p>
<h2>A python analogy</h2>
<p>In python, there is a neat buitin called <code>zip</code>. Essentially, <code>zip</code> takes an
arbitrary set of lists as an argument, and returns an iterator of tuples,
such that the first tuple is composed of the first element of each list,
the second tuple has the second element of each list, and so on. It always
goes better with an example:</p>
<div class="highlight"><pre>&gt;&gt;&gt; for t in zip([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;], [1, 2, 3, 4], [&#39;!&#39;, &#39;@&#39;, &#39;#&#39;, &#39;%&#39;]):
...     print(t)
...
(&#39;a&#39;, 1, &#39;!&#39;)
(&#39;b&#39;, 2, &#39;@&#39;)
(&#39;c&#39;, 3, &#39;#&#39;)
(&#39;d&#39;, 4, &#39;%&#39;)
</pre></div>


<p>The question is, how can we produce a similar function in a legacy shell?</p>
<h2>Let's specify</h2>
<p>Our goal is to produce a shell function that we will also conveniently
name <code>zip</code>. Of course, this function must work in legacy shells such as
ash or dash. It will expect an unspecified number of lists as arguments,
and return a flattened list of tuples, where the iᵗʰ tuple is composed of
all of the iᵗʰ elements of each list. Like in python, if the lists
provided as arguments are not of equal lengths, the result will be cut at
the shortest length. Here are examples of expected behaviour:</p>
<div class="highlight"><pre># 3 lists of same length
$ zip &quot;a b c d&quot; &quot;1 2 3 4&quot; &quot;! @ # %&quot;
 a 1 !
 b 2 @
 c 3 #
 d 4 %

# 1 list
$ zip &quot;a b c d&quot;
 a
 b
 c
 d

# 2 lists of different length
$ zip &quot;a b&quot; &quot;1 2 3&quot;
 a 1
 b 2

# 0 list
$ zip
</pre></div>


<p>How to use it would then just be a matter of using the set builtin:</p>
<div class="highlight"><pre>$ <span class="nv">list1</span><span class="o">=</span><span class="s2">&quot;1 2 3 4&quot;</span>
$ <span class="nv">list2</span><span class="o">=</span><span class="s2">&quot;a b c d&quot;</span>
$ <span class="nb">set</span> <span class="k">$(</span>zip <span class="s2">&quot;</span>$<span class="s2">list1&quot;</span> <span class="s2">&quot;</span>$<span class="s2">list2&quot;</span><span class="k">)</span>
$ <span class="k">for</span> i in <span class="k">$(</span>seq <span class="m">1</span> 4<span class="k">)</span><span class="p">;</span> <span class="k">do</span> <span class="se">\</span>
    <span class="nb">echo</span> <span class="s2">&quot;processing </span><span class="nv">$1</span><span class="s2"> and </span><span class="nv">$2</span><span class="s2">&quot;</span><span class="p">;</span> <span class="se">\</span>
    <span class="nb">shift</span> 2<span class="p">;</span> <span class="se">\</span>
<span class="k">done</span>
processing <span class="m">1</span> and a
processing <span class="m">2</span> and b
processing <span class="m">3</span> and c
processing <span class="m">4</span> and d
</pre></div>


<h2>The implementation</h2>
<p>It is often not obvious to the beginner how to create variable names out
of other variables. For example, the name <code>list$i</code> is an illegal variable
name, so you cannot do:</p>
<div class="highlight"><pre><span class="x">i=1</span>
<span class="x">list</span><span class="p">$</span><span class="nv">i</span><span class="x">=&quot;a b c&quot;</span>
</pre></div>


<p>What is the way to get around that? The answer is <code>eval</code>, of course!</p>
<div class="highlight"><pre><span class="x">i=1</span>
<span class="x">eval &quot;list</span><span class="p">$</span><span class="nv">i</span><span class="x">=&#39;a b c&#39;&quot;</span>
</pre></div>


<p>So our zip function begins like this</p>
<div class="highlight"><pre><span class="x">zip()</span><span class="err">{</span><span class="x"></span>
<span class="x">    nlists=</span><span class="p">$</span><span class="err">#</span><span class="x"></span>
<span class="x">    for i in </span><span class="p">$(</span><span class="err">seq</span> <span class="m">1</span> <span class="p">$</span><span class="nv">nlists</span><span class="p">)</span><span class="x">; do</span>
<span class="x">        eval &quot;list</span><span class="p">$</span><span class="nv">i</span><span class="x">=&#39;</span><span class="p">$</span><span class="x">1&#39;&quot;</span>
<span class="x">        shift</span>
<span class="x">    done</span>
<span class="x">    </span><span class="err">#</span><span class="x"> the input lists are now in the variable named list1, list2....</span>
<span class="x">    [...]</span>
<span class="x">}</span>
</pre></div>


<p>We would like to loop over all lists, extract the first element, append it
to the tuple, and update the list to reflect the tail. The least error
prone way I have found to extract the first element is to use a printf
construct</p>
<div class="highlight"><pre>$ <span class="nb">printf</span> <span class="s2">&quot;%s\n&quot;</span> a b c d
a
b
c
d
</pre></div>


<p>This prints all element of the list line by line. One can easily combine
it with <code>head -n1</code> and <code>tail -n+2</code> to get the head or the tail of the
list.</p>
<div class="highlight"><pre><span class="x">head=</span><span class="p">$(</span><span class="err">printf</span> <span class="s1">&#39;%s\n&#39;</span> <span class="p">$</span><span class="nv">list</span> <span class="err">|</span> <span class="err">head</span> <span class="err">-n1</span><span class="p">)</span><span class="x"></span>
<span class="x">tail=</span><span class="p">$(</span><span class="err">printf</span> <span class="s1">&#39;%s\n&#39;</span> <span class="p">$</span><span class="nv">list</span> <span class="err">|</span> <span class="err">tail</span> <span class="err">-n+</span><span class="m">2</span><span class="p">)</span><span class="x"></span>
</pre></div>


<p>It works more reliably, for example, than using the buitin <code>set</code> to put the
elements of the list in the argument list <code>$1</code>, <code>$2</code></p>
<div class="highlight"><pre><span class="x">set </span><span class="p">$</span><span class="nv">list</span><span class="x"></span>
<span class="x">head=</span><span class="p">$</span><span class="x">1</span>
<span class="x">shift</span>
<span class="x">tail=&quot;</span><span class="p">$</span><span class="x">*&quot;</span>
</pre></div>


<p>Why? The reason is that if the first argument is the string litteral <code>-</code>, set
will not behave the way we want! The second part of the function therefore
looks like this, with a bunch of <code>eval</code>s</p>
<div class="highlight"><pre><span class="x">while true; do</span>
<span class="x">    tuple=&quot;&quot;</span>
<span class="x">    for i in </span><span class="p">$(</span><span class="err">seq</span> <span class="m">1</span> <span class="p">$</span><span class="nv">nlists</span><span class="p">)</span><span class="x">; do</span>
<span class="x">        eval &quot;[ -z \&quot;\</span><span class="p">$</span><span class="nv">list</span><span class="p">$</span><span class="nv">i</span><span class="x">\&quot; ] &amp;&amp; return 0&quot;</span>
<span class="x">        eval &quot;head=\</span><span class="p">$(</span><span class="err">printf</span> <span class="s1">&#39;%s\\n&#39;</span> <span class="err">\</span><span class="p">$</span><span class="nv">list</span><span class="p">$</span><span class="nv">i</span> <span class="err">|</span> <span class="err">head</span> <span class="err">-n1</span><span class="p">)</span><span class="x">&quot;</span>
<span class="x">        eval &quot;list</span><span class="p">$</span><span class="nv">i</span><span class="x">=\</span><span class="p">$(</span><span class="err">printf</span> <span class="s1">&#39;%s\\n&#39;</span> <span class="err">\</span><span class="p">$</span><span class="nv">list</span><span class="p">$</span><span class="nv">i</span> <span class="err">|</span> <span class="err">tail</span> <span class="err">-n+</span><span class="m">2</span><span class="p">)</span><span class="x">&quot;</span>
<span class="x">        tuple=&quot;</span><span class="p">$</span><span class="nv">tuple</span><span class="x"> </span><span class="p">$</span><span class="nv">head</span><span class="x">&quot;</span>
<span class="x">    done</span>
<span class="x">    echo &quot;</span><span class="p">$</span><span class="nv">tuple</span><span class="x">&quot;</span>
<span class="x">done</span>
</pre></div>


<p>This looks about right: when one of the lists is empty, we know we will
not be able to complete the current tuple, so we return immediately
without further <code>echo</code>ing. The devil is in the details, because if
provided with zero argument, this function will loop forever. However, we
really want to start looping if and only if there are arguments. This
could be achieved by changing</p>
<div class="highlight"><pre>while true; do
</pre></div>


<p>to</p>
<div class="highlight"><pre><span class="x">while [ </span><span class="p">$</span><span class="nv">nlists</span><span class="x"> != 0 ]; do</span>
</pre></div>


<p>I don't find this construct very readable, as it makes it look like this
condition could change during the loops. I'd rather add the check</p>
<div class="highlight"><pre><span class="x">[ </span><span class="p">$</span><span class="nv">nlist</span><span class="x"> = 0 ] &amp;&amp; return 0</span>
</pre></div>


<p>at the beginning of the function.</p>
<h2>The result</h2>
<p>Here is how the code looks at the end. I think this could be a fun
interview question!</p>
<div class="highlight"><pre><span class="x">zip()</span><span class="err">{</span><span class="x"></span>
<span class="x">    nlists=</span><span class="p">$</span><span class="err">#</span><span class="x"></span>
<span class="x">    [ </span><span class="p">$</span><span class="nv">nlists</span><span class="x"> = 0 ] &amp;&amp; return 0</span>
<span class="x">    for i in </span><span class="p">$(</span><span class="err">seq</span> <span class="m">1</span> <span class="p">$</span><span class="nv">nlists</span><span class="p">)</span><span class="x">; do</span>
<span class="x">        eval &quot;list</span><span class="p">$</span><span class="nv">i</span><span class="x">=&#39;</span><span class="p">$</span><span class="x">1&#39;&quot;</span>
<span class="x">        shift</span>
<span class="x">    done</span>
<span class="x">    while true; do</span>
<span class="x">        tuple=&quot;&quot;</span>
<span class="x">        for i in </span><span class="p">$(</span><span class="err">seq</span> <span class="m">1</span> <span class="p">$</span><span class="nv">nlists</span><span class="p">)</span><span class="x">; do</span>
<span class="x">            eval &quot;[ -z \&quot;\</span><span class="p">$</span><span class="nv">list</span><span class="p">$</span><span class="nv">i</span><span class="x">\&quot; ] &amp;&amp; return 0&quot;</span>
<span class="x">            eval &quot;head=\</span><span class="p">$(</span><span class="err">printf</span> <span class="s1">&#39;%s\\n&#39;</span> <span class="err">\</span><span class="p">$</span><span class="nv">list</span><span class="p">$</span><span class="nv">i</span> <span class="err">|</span> <span class="err">head</span> <span class="err">-n1</span><span class="p">)</span><span class="x">&quot;</span>
<span class="x">            eval &quot;list</span><span class="p">$</span><span class="nv">i</span><span class="x">=\</span><span class="p">$(</span><span class="err">printf</span> <span class="s1">&#39;%s\\n&#39;</span> <span class="err">\</span><span class="p">$</span><span class="nv">list</span><span class="p">$</span><span class="nv">i</span> <span class="err">|</span> <span class="err">tail</span> <span class="err">-n+</span><span class="m">2</span><span class="p">)</span><span class="x">&quot;</span>
<span class="x">            tuple=&quot;</span><span class="p">$</span><span class="nv">tuple</span><span class="x"> </span><span class="p">$</span><span class="nv">head</span><span class="x">&quot;</span>
<span class="x">        done</span>
<span class="x">        echo &quot;</span><span class="p">$</span><span class="nv">tuple</span><span class="x">&quot;</span>
<span class="x">    done</span>
<span class="x">}</span>
</pre></div>


<p>Do you think it can be improved? Do you have your own different technique
to achieve this? Let me know in the comments!</p>
    </div>
    <div class="comments">
        <h2>Comments !</h2>
        <!-- hack to add flattr -->
        <script id='fbnrl3e'>(function(i){var f,s=document.getElementById(i);f=document.createElement('iframe');f.src='//api.flattr.com/button/view/?uid=chmd&button=compact&url='+encodeURIComponent(document.URL);f.title='Flattr';f.height=20;f.width=110;f.style.borderWidth=0;s.parentNode.insertBefore(f,s);})('fbnrl3e');</script>
        <div id="disqus_thread"></div>
        <script type="text/javascript">
            var disqus_identifier = "looping-simultaneously-over-multiple-lists-in-legacy-shells.html";
            (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = '//chmd.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        </div>
</article>
</section>
    <footer id="contentinfo" class="body">
        <address id="about" class="vcard body">
        Generated by <a href="http://getpelican.com/">pelican</a>,
        theme <a href="https://github.com/chmduquesne/small">small</a>
        </address><!-- /#about -->
    </footer><!-- /#contentinfo -->
</body>
</html>